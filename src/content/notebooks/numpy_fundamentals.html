<div class="blog-content">
    <p class="lead">NumPy (Numerical Python) is the foundation of scientific computing in Python. It provides high-performance multidimensional arrays and mathematical functions that are essential for machine learning and data science.</p>

    <h2>Why NumPy Matters for ML</h2>
    <ul>
        <li><strong>Performance</strong>: Vectorized operations in C, orders of magnitude faster than pure Python</li>
        <li><strong>Memory Efficiency</strong>: Homogeneous arrays with fixed data types</li>
        <li><strong>Broadcasting</strong>: Elegant handling of operations between different-shaped arrays</li>
        <li><strong>Foundation</strong>: Almost all ML libraries (scikit-learn, TensorFlow, PyTorch) are built on NumPy</li>
    </ul>

    <h2>Array Creation and Basic Operations</h2>
    <p>Understanding different ways to create and manipulate arrays:</p>

    <pre><code class="language-python">import numpy as np

# Different ways to create arrays
arr1 = np.array([1, 2, 3, 4, 5])
arr2 = np.array([[1, 2, 3], [4, 5, 6]])

print(f"1D array: {arr1}")
print(f"2D array:\n{arr2}")
print(f"Shape: {arr2.shape}, Dimensions: {arr2.ndim}, Size: {arr2.size}")

# Common array creation functions
zeros = np.zeros((3, 4))
ones = np.ones((2, 3))
identity = np.eye(3)
random_arr = np.random.random((2, 3))
arange_arr = np.arange(0, 10, 2)
linspace_arr = np.linspace(0, 1, 5)

print(f"Zeros:\n{zeros}")
print(f"Identity matrix:\n{identity}")
print(f"Arange: {arange_arr}")
print(f"Linspace: {linspace_arr}")
</code></pre>

    <h2>Broadcasting: The Power of NumPy</h2>
    <p>Broadcasting allows operations between arrays of different shapes:</p>

    <pre><code class="language-python"># Basic broadcasting
arr = np.array([[1, 2, 3], [4, 5, 6]])
scalar = 10
print(f"Array + scalar:\n{arr + scalar}")

# Vector broadcasting
vector = np.array([10, 20, 30])
print(f"Array + vector:\n{arr + vector}")

# More complex broadcasting
matrix_a = np.array([[1], [2], [3]])  # (3, 1)
matrix_b = np.array([10, 20])         # (2,)
result = matrix_a + matrix_b          # Results in (3, 2)

print(f"Broadcasted result (3,2):\n{result}")

# Practical example: Normalizing data
data = np.random.randn(100, 3)  # 100 samples, 3 features
mean = np.mean(data, axis=0)    # Mean of each feature
std = np.std(data, axis=0)      # Std of each feature

# Broadcasting for standardization
normalized_data = (data - mean) / std
print(f"Normalized means: {np.mean(normalized_data, axis=0)}")
print(f"Normalized stds: {np.std(normalized_data, axis=0)}")
</code></pre>

    <h2>Mathematical Operations and Linear Algebra</h2>
    <p>Essential operations for machine learning:</p>

    <pre><code class="language-python"># Element-wise operations
a = np.array([1, 2, 3, 4])
b = np.array([5, 6, 7, 8])

print(f"a + b = {a + b}")
print(f"a * b = {a * b}")
print(f"a ** 2 = {a ** 2}")

# Matrix operations
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

print(f"Matrix multiplication A @ B:\n{A @ B}")
print(f"Element-wise multiplication A * B:\n{A * B}")

# Important linear algebra operations
print(f"Determinant of A: {np.linalg.det(A):.3f}")
print(f"Inverse of A:\n{np.linalg.inv(A)}")
print(f"Eigenvalues: {np.linalg.eigvals(A)}")

# Vector operations
v1 = np.array([1, 2, 3])
v2 = np.array([4, 5, 6])

print(f"Dot product: {np.dot(v1, v2)}")
print(f"L2 norm of v1: {np.linalg.norm(v1):.3f}")
</code></pre>

    <h2>Performance: NumPy vs Pure Python</h2>
    <p>NumPy's performance advantage is substantial:</p>

    <pre><code class="language-python">import time

size = 1000000
python_list = list(range(size))
numpy_array = np.arange(size)

# Sum operation comparison
start_time = time.time()
python_sum = sum(python_list)
python_time = time.time() - start_time

start_time = time.time()
numpy_sum = np.sum(numpy_array)
numpy_time = time.time() - start_time

print(f"Python list: {python_time:.4f} seconds")
print(f"NumPy array: {numpy_time:.4f} seconds")
print(f"Speedup: {python_time / numpy_time:.1f}x")
</code></pre>

    <blockquote>
        <strong>Result</strong>: NumPy is typically 10-100x faster than pure Python for numerical operations!
    </blockquote>

    <h2>Practical ML Examples</h2>

    <h3>Distance Calculations (KNN, Clustering)</h3>
    <pre><code class="language-python"># Vectorized distance calculation
data_points = np.random.randn(100, 2)  # 100 points in 2D
query_point = np.array([0.5, 0.5])

# Calculate all distances at once
distances = np.sqrt(np.sum((data_points - query_point) ** 2, axis=1))
nearest_idx = np.argmin(distances)

print(f"Nearest neighbor: {data_points[nearest_idx]}")
print(f"Distance: {distances[nearest_idx]:.3f}")
</code></pre>

    <h3>Activation Functions</h3>
    <pre><code class="language-python">def sigmoid(x):
    return 1 / (1 + np.exp(-np.clip(x, -500, 500)))

def relu(x):
    return np.maximum(0, x)

def softmax(x):
    exp_x = np.exp(x - np.max(x))  # Numerical stability
    return exp_x / np.sum(exp_x)

# Test softmax
logits = np.array([2.0, 1.0, 0.1])
probabilities = softmax(logits)
print(f"Logits: {logits}")
print(f"Softmax probabilities: {probabilities}")
print(f"Sum: {np.sum(probabilities)}")  # Should be 1.0
</code></pre>

    <h2>Essential Functions for ML</h2>

    <h3>Array Creation</h3>
    <pre><code class="language-python"># Key functions
np.zeros(), np.ones(), np.random.randn(), np.linspace()
</code></pre>

    <h3>Reshaping</h3>
    <pre><code class="language-python"># Shape manipulation
arr.reshape(), arr.flatten(), arr.T
</code></pre>

    <h3>Indexing</h3>
    <pre><code class="language-python"># Powerful indexing
arr[mask], arr[indices], arr[:, 1:3]
</code></pre>

    <h3>Math Operations</h3>
    <pre><code class="language-python"># Mathematical functions
np.sum(), np.mean(), np.std(), np.dot(), np.linalg.norm()
</code></pre>

    <h3>Utilities</h3>
    <pre><code class="language-python"># Helpful utilities
np.where(), np.clip(), np.argmax(), np.argsort()
</code></pre>

    <h2>Best Practices</h2>

    <h3>Performance Tips</h3>
    <ul>
        <li><strong>Vectorize operations</strong>: Avoid explicit loops when possible</li>
        <li><strong>Use appropriate data types</strong>: float32 vs float64, int32 vs int64</li>
        <li><strong>Understand views vs copies</strong>: Use views to save memory</li>
        <li><strong>Leverage broadcasting</strong>: Elegant operations between different shapes</li>
    </ul>

    <h3>Memory Optimization</h3>
    <ul>
        <li>Pre-allocate arrays when size is known</li>
        <li>Use in-place operations when possible (<code>+=</code>, <code>*=</code>)</li>
        <li>Choose appropriate precision based on your needs</li>
        <li>Profile your code to identify bottlenecks</li>
    </ul>

    <h2>Integration with ML Libraries</h2>
    <ul>
        <li><strong>Scikit-learn</strong>: Expects NumPy arrays as input</li>
        <li><strong>TensorFlow/PyTorch</strong>: Convert easily with <code>.numpy()</code> and tensor constructors</li>
        <li><strong>Pandas</strong>: Built on NumPy, seamless integration</li>
        <li><strong>Matplotlib</strong>: Native NumPy array plotting</li>
    </ul>

    <p>NumPy mastery is fundamental for effective machine learning in Python. These concepts form the foundation for understanding and implementing ML algorithms efficiently!</p>
</div>